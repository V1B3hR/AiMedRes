# Vulnerability Management Process Guide

## Overview

This guide provides comprehensive instructions for vulnerability management in AiMedRes, including security scanning, dependency audits, penetration testing, and remediation processes.

## Vulnerability Management Lifecycle

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Vulnerability Management Lifecycle        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  1. Discovery     ‚Üí Scan & Identify          ‚îÇ
‚îÇ  2. Assessment    ‚Üí Analyze & Prioritize     ‚îÇ
‚îÇ  3. Remediation   ‚Üí Fix & Validate           ‚îÇ
‚îÇ  4. Reporting     ‚Üí Document & Communicate   ‚îÇ
‚îÇ  5. Monitoring    ‚Üí Continuous Validation    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Container Security Scanning

### Docker Image Scanning with Trivy

#### Installation

```bash
# Install Trivy
sudo apt-get install wget apt-transport-https gnupg lsb-release
wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
sudo apt-get update
sudo apt-get install trivy
```

#### Scan Docker Images

```bash
# Scan AiMedRes Docker image
trivy image --severity HIGH,CRITICAL aimedres:latest

# Generate detailed report
trivy image --format json --output trivy-report.json aimedres:latest

# Scan with exit code on vulnerabilities
trivy image --exit-code 1 --severity HIGH,CRITICAL aimedres:latest
```

#### Automated Scanning Script

```bash
#!/bin/bash
# scan_docker_images.sh

set -e

IMAGES=("aimedres:latest" "aimedres-api:latest" "aimedres-worker:latest")
REPORT_DIR="./security-reports"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

mkdir -p "$REPORT_DIR"

echo "üîç Starting Docker image vulnerability scan..."

for IMAGE in "${IMAGES[@]}"; do
    echo "Scanning $IMAGE..."
    
    # Scan image
    trivy image \
        --severity HIGH,CRITICAL \
        --format json \
        --output "$REPORT_DIR/${IMAGE//:/_}_${TIMESTAMP}.json" \
        "$IMAGE"
    
    # Check for vulnerabilities
    VULN_COUNT=$(trivy image --severity HIGH,CRITICAL --format json "$IMAGE" | jq '.Results[].Vulnerabilities | length' | awk '{s+=$1} END {print s}')
    
    if [ "$VULN_COUNT" -gt 0 ]; then
        echo "‚ùå Found $VULN_COUNT HIGH/CRITICAL vulnerabilities in $IMAGE"
        exit 1
    else
        echo "‚úÖ No HIGH/CRITICAL vulnerabilities found in $IMAGE"
    fi
done

echo "‚úÖ All images scanned successfully"
```

Make executable and run:

```bash
chmod +x scan_docker_images.sh
./scan_docker_images.sh
```

### Clair Integration (Alternative)

```yaml
# docker-compose.yml with Clair
version: '3.8'

services:
  clair:
    image: quay.io/coreos/clair:latest
    ports:
      - "6060:6060"
      - "6061:6061"
    volumes:
      - ./clair-config:/config
    command: ["-config", "/config/config.yaml"]
  
  clair-db:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: password
```

## Dependency Vulnerability Scanning

### Python Dependencies with Safety

#### Installation

```bash
pip install safety
```

#### Scan Python Dependencies

```bash
# Scan installed packages
safety check

# Scan requirements.txt
safety check --file requirements.txt

# Generate JSON report
safety check --json --output safety-report.json

# Scan with exit code on vulnerabilities
safety check --exit-code 1
```

#### Automated Dependency Scanning

```python
import subprocess
import json
from datetime import datetime

def scan_python_dependencies():
    """Scan Python dependencies for vulnerabilities"""
    
    print("üîç Scanning Python dependencies...")
    
    try:
        # Run safety check
        result = subprocess.run(
            ['safety', 'check', '--json'],
            capture_output=True,
            text=True
        )
        
        # Parse results
        vulnerabilities = json.loads(result.stdout)
        
        if vulnerabilities:
            print(f"‚ùå Found {len(vulnerabilities)} vulnerabilities:")
            
            for vuln in vulnerabilities:
                print(f"\n  Package: {vuln[0]}")
                print(f"  Installed: {vuln[2]}")
                print(f"  Vulnerability: {vuln[3]}")
                print(f"  Recommendation: {vuln[4]}")
            
            # Generate report
            report = {
                'timestamp': datetime.now().isoformat(),
                'vulnerabilities': vulnerabilities,
                'total_count': len(vulnerabilities)
            }
            
            with open('dependency-scan-report.json', 'w') as f:
                json.dump(report, f, indent=2)
            
            return False
        else:
            print("‚úÖ No vulnerabilities found in dependencies")
            return True
            
    except Exception as e:
        print(f"‚ùå Error scanning dependencies: {e}")
        return False

if __name__ == '__main__':
    scan_python_dependencies()
```

### npm/JavaScript Dependencies (if applicable)

```bash
# Scan npm dependencies
npm audit

# Generate detailed report
npm audit --json > npm-audit-report.json

# Fix vulnerabilities automatically
npm audit fix

# Fix with breaking changes (use with caution)
npm audit fix --force
```

## Code Security Scanning

### Bandit for Python

#### Installation

```bash
pip install bandit
```

#### Scan Python Code

```bash
# Scan entire codebase
bandit -r src/

# Scan with severity filter
bandit -r src/ -ll  # Only HIGH and MEDIUM

# Generate JSON report
bandit -r src/ -f json -o bandit-report.json

# Exclude test files
bandit -r src/ --exclude */tests/*
```

#### Automated Code Scanning

```bash
#!/bin/bash
# scan_python_code.sh

echo "üîç Scanning Python code for security issues..."

bandit -r src/ \
    --severity-level medium \
    --confidence-level medium \
    --format json \
    --output bandit-report.json

# Check exit code
if [ $? -eq 0 ]; then
    echo "‚úÖ No security issues found"
else
    echo "‚ùå Security issues detected - review bandit-report.json"
    cat bandit-report.json | jq '.results[] | {severity, confidence, issue_text, test_id}'
    exit 1
fi
```

### Semgrep for Multi-Language Scanning

#### Installation

```bash
pip install semgrep
```

#### Scan with Security Rules

```bash
# Scan with OWASP Top 10 rules
semgrep --config=p/owasp-top-ten src/

# Scan with security rules
semgrep --config=p/security-audit src/

# Generate JSON report
semgrep --config=p/security-audit --json --output semgrep-report.json src/
```

### SAST Integration (GitHub CodeQL)

Already integrated via `codeql_checker` tool. Example configuration:

```yaml
# .github/workflows/security-scan.yml
name: Security Scan

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 0 * * 0'  # Weekly scan

jobs:
  codeql:
    name: CodeQL Analysis
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Initialize CodeQL
      uses: github/codeql-action/init@v2
      with:
        languages: python
        queries: security-and-quality
    
    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v2
```

## Penetration Testing

### Automated Web Application Scanning with OWASP ZAP

#### Installation

```bash
# Install OWASP ZAP
docker pull owasp/zap2docker-stable
```

#### Run Baseline Scan

```bash
#!/bin/bash
# pen_test_baseline.sh

TARGET_URL="https://aimedres.hospital.org"
REPORT_DIR="./pentest-reports"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

mkdir -p "$REPORT_DIR"

echo "üîç Starting OWASP ZAP baseline scan..."

docker run -v "$(pwd)/$REPORT_DIR:/zap/wrk:rw" \
    -t owasp/zap2docker-stable \
    zap-baseline.py \
    -t "$TARGET_URL" \
    -r "baseline_report_${TIMESTAMP}.html" \
    -J "baseline_report_${TIMESTAMP}.json"

echo "‚úÖ Baseline scan complete"
```

#### Full Scan (More Comprehensive)

```bash
#!/bin/bash
# pen_test_full.sh

TARGET_URL="https://aimedres.hospital.org"
REPORT_DIR="./pentest-reports"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

mkdir -p "$REPORT_DIR"

echo "üîç Starting OWASP ZAP full scan..."

docker run -v "$(pwd)/$REPORT_DIR:/zap/wrk:rw" \
    -t owasp/zap2docker-stable \
    zap-full-scan.py \
    -t "$TARGET_URL" \
    -r "full_report_${TIMESTAMP}.html" \
    -J "full_report_${TIMESTAMP}.json"

echo "‚úÖ Full scan complete"
```

### API Security Testing

```python
import requests
import json

class APISecurityTester:
    """Automated API security testing"""
    
    def __init__(self, base_url: str):
        self.base_url = base_url
        self.results = []
    
    def test_authentication(self):
        """Test authentication vulnerabilities"""
        
        tests = [
            ('Missing Auth', None),
            ('Invalid Token', 'invalid_token'),
            ('Expired Token', 'expired_token'),
        ]
        
        for test_name, token in tests:
            headers = {'Authorization': f'Bearer {token}'} if token else {}
            
            response = requests.get(
                f'{self.base_url}/api/v1/secure/data',
                headers=headers
            )
            
            result = {
                'test': test_name,
                'status_code': response.status_code,
                'vulnerable': response.status_code == 200
            }
            
            self.results.append(result)
            
            if result['vulnerable']:
                print(f"‚ùå Vulnerability: {test_name}")
            else:
                print(f"‚úÖ Protected: {test_name}")
    
    def test_injection(self):
        """Test SQL/NoSQL injection"""
        
        payloads = [
            "' OR '1'='1",
            "1; DROP TABLE users--",
            "' UNION SELECT * FROM users--",
        ]
        
        for payload in payloads:
            response = requests.post(
                f'{self.base_url}/api/v1/search',
                json={'query': payload}
            )
            
            # Check if payload was executed
            vulnerable = (
                response.status_code == 200 and
                'error' not in response.text.lower()
            )
            
            result = {
                'test': 'SQL Injection',
                'payload': payload,
                'vulnerable': vulnerable
            }
            
            self.results.append(result)
            
            if vulnerable:
                print(f"‚ùå Potential SQL injection: {payload}")
    
    def test_xss(self):
        """Test Cross-Site Scripting (XSS)"""
        
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
        ]
        
        for payload in payloads:
            response = requests.post(
                f'{self.base_url}/api/v1/data',
                json={'input': payload}
            )
            
            # Check if payload is reflected without encoding
            vulnerable = payload in response.text
            
            result = {
                'test': 'XSS',
                'payload': payload,
                'vulnerable': vulnerable
            }
            
            self.results.append(result)
            
            if vulnerable:
                print(f"‚ùå XSS vulnerability: {payload}")
    
    def test_rate_limiting(self):
        """Test rate limiting"""
        
        print("üîç Testing rate limiting...")
        
        successful_requests = 0
        for i in range(100):
            response = requests.get(f'{self.base_url}/api/v1/health')
            
            if response.status_code == 200:
                successful_requests += 1
            elif response.status_code == 429:
                print(f"‚úÖ Rate limiting active after {i+1} requests")
                break
        
        if successful_requests >= 100:
            print("‚ùå No rate limiting detected")
            self.results.append({
                'test': 'Rate Limiting',
                'vulnerable': True
            })
    
    def generate_report(self):
        """Generate security test report"""
        
        vulnerable_tests = [r for r in self.results if r.get('vulnerable')]
        
        report = {
            'timestamp': datetime.now().isoformat(),
            'total_tests': len(self.results),
            'vulnerabilities_found': len(vulnerable_tests),
            'results': self.results
        }
        
        with open('api-security-report.json', 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"\nüìä Security Test Summary:")
        print(f"  Total tests: {report['total_tests']}")
        print(f"  Vulnerabilities: {report['vulnerabilities_found']}")

# Usage
tester = APISecurityTester('https://aimedres.hospital.org')
tester.test_authentication()
tester.test_injection()
tester.test_xss()
tester.test_rate_limiting()
tester.generate_report()
```

## Vulnerability Assessment and Prioritization

### CVSS Scoring

```python
from enum import Enum

class CVSSSeverity(Enum):
    CRITICAL = (9.0, 10.0)
    HIGH = (7.0, 8.9)
    MEDIUM = (4.0, 6.9)
    LOW = (0.1, 3.9)
    NONE = (0.0, 0.0)

class VulnerabilityAssessment:
    """Assess and prioritize vulnerabilities"""
    
    def __init__(self):
        self.vulnerabilities = []
    
    def add_vulnerability(self, vuln: dict):
        """Add vulnerability for assessment"""
        
        # Calculate priority score
        priority = self.calculate_priority(
            cvss_score=vuln.get('cvss_score', 0),
            exploitability=vuln.get('exploitability', 'low'),
            asset_criticality=vuln.get('asset_criticality', 'medium')
        )
        
        vuln['priority'] = priority
        vuln['severity'] = self.get_severity(vuln['cvss_score'])
        
        self.vulnerabilities.append(vuln)
    
    def calculate_priority(self, cvss_score: float, 
                          exploitability: str, 
                          asset_criticality: str) -> int:
        """Calculate priority score (1-10, 10 being highest)"""
        
        # Base score from CVSS
        base_score = cvss_score
        
        # Exploitability multiplier
        exploit_multiplier = {
            'high': 1.5,
            'medium': 1.2,
            'low': 1.0
        }.get(exploitability, 1.0)
        
        # Asset criticality multiplier
        asset_multiplier = {
            'critical': 1.5,
            'high': 1.3,
            'medium': 1.0,
            'low': 0.8
        }.get(asset_criticality, 1.0)
        
        priority = base_score * exploit_multiplier * asset_multiplier
        
        return min(int(priority), 10)
    
    def get_severity(self, cvss_score: float) -> str:
        """Get severity level from CVSS score"""
        
        for severity in CVSSSeverity:
            min_score, max_score = severity.value
            if min_score <= cvss_score <= max_score:
                return severity.name
        
        return 'UNKNOWN'
    
    def get_prioritized_vulnerabilities(self):
        """Get vulnerabilities sorted by priority"""
        
        return sorted(
            self.vulnerabilities,
            key=lambda v: v['priority'],
            reverse=True
        )
    
    def generate_remediation_plan(self):
        """Generate vulnerability remediation plan"""
        
        prioritized = self.get_prioritized_vulnerabilities()
        
        plan = {
            'immediate_action': [],  # Priority 9-10
            'short_term': [],        # Priority 7-8
            'medium_term': [],       # Priority 4-6
            'long_term': []          # Priority 1-3
        }
        
        for vuln in prioritized:
            if vuln['priority'] >= 9:
                plan['immediate_action'].append(vuln)
            elif vuln['priority'] >= 7:
                plan['short_term'].append(vuln)
            elif vuln['priority'] >= 4:
                plan['medium_term'].append(vuln)
            else:
                plan['long_term'].append(vuln)
        
        return plan

# Usage
assessment = VulnerabilityAssessment()

assessment.add_vulnerability({
    'id': 'CVE-2024-12345',
    'description': 'SQL Injection in patient search',
    'cvss_score': 9.1,
    'exploitability': 'high',
    'asset_criticality': 'critical'
})

assessment.add_vulnerability({
    'id': 'CVE-2024-12346',
    'description': 'Outdated library with known vulnerability',
    'cvss_score': 5.3,
    'exploitability': 'low',
    'asset_criticality': 'medium'
})

# Generate remediation plan
plan = assessment.generate_remediation_plan()

print("Immediate Action Required:")
for vuln in plan['immediate_action']:
    print(f"  - {vuln['id']}: {vuln['description']} (Priority: {vuln['priority']})")
```

## Remediation Process

### Vulnerability Remediation Workflow

```python
from enum import Enum
from datetime import datetime, timedelta

class RemediationStatus(Enum):
    OPEN = "open"
    IN_PROGRESS = "in_progress"
    RESOLVED = "resolved"
    WONT_FIX = "wont_fix"
    RISK_ACCEPTED = "risk_accepted"

class VulnerabilityRemediation:
    """Track vulnerability remediation"""
    
    def __init__(self):
        self.remediations = {}
    
    def create_ticket(self, vuln_id: str, vuln_data: dict) -> str:
        """Create remediation ticket"""
        
        ticket_id = f"REM-{len(self.remediations) + 1:04d}"
        
        # Calculate SLA based on priority
        sla_days = {
            10: 1,   # Critical - 1 day
            9: 3,    # Critical - 3 days
            8: 7,    # High - 7 days
            7: 14,   # High - 14 days
            6: 30,   # Medium - 30 days
            5: 30,
            4: 60,   # Low - 60 days
        }.get(vuln_data.get('priority', 5), 90)
        
        ticket = {
            'ticket_id': ticket_id,
            'vuln_id': vuln_id,
            'vulnerability': vuln_data,
            'status': RemediationStatus.OPEN,
            'created_at': datetime.now(),
            'sla_deadline': datetime.now() + timedelta(days=sla_days),
            'assigned_to': None,
            'updates': []
        }
        
        self.remediations[ticket_id] = ticket
        
        print(f"‚úÖ Remediation ticket created: {ticket_id}")
        print(f"   SLA deadline: {ticket['sla_deadline'].strftime('%Y-%m-%d')}")
        
        return ticket_id
    
    def update_status(self, ticket_id: str, status: RemediationStatus, 
                     notes: str = None):
        """Update remediation status"""
        
        if ticket_id not in self.remediations:
            raise ValueError(f"Ticket not found: {ticket_id}")
        
        ticket = self.remediations[ticket_id]
        
        update = {
            'timestamp': datetime.now(),
            'old_status': ticket['status'],
            'new_status': status,
            'notes': notes
        }
        
        ticket['updates'].append(update)
        ticket['status'] = status
        
        if status == RemediationStatus.RESOLVED:
            ticket['resolved_at'] = datetime.now()
            
            # Check if within SLA
            within_sla = ticket['resolved_at'] <= ticket['sla_deadline']
            ticket['within_sla'] = within_sla
            
            if within_sla:
                print(f"‚úÖ Ticket resolved within SLA: {ticket_id}")
            else:
                print(f"‚ö†Ô∏è  Ticket resolved outside SLA: {ticket_id}")
        
        print(f"üìù Ticket updated: {ticket_id} ‚Üí {status.value}")
    
    def get_overdue_tickets(self):
        """Get tickets past SLA deadline"""
        
        now = datetime.now()
        overdue = []
        
        for ticket_id, ticket in self.remediations.items():
            if (ticket['status'] not in [RemediationStatus.RESOLVED, 
                                         RemediationStatus.WONT_FIX,
                                         RemediationStatus.RISK_ACCEPTED] and
                ticket['sla_deadline'] < now):
                overdue.append(ticket)
        
        return overdue

# Usage
remediation = VulnerabilityRemediation()

# Create ticket for critical vulnerability
ticket_id = remediation.create_ticket('CVE-2024-12345', {
    'description': 'SQL Injection',
    'priority': 10
})

# Update status
remediation.update_status(
    ticket_id,
    RemediationStatus.IN_PROGRESS,
    notes="Patch identified, testing in progress"
)

# Mark as resolved
remediation.update_status(
    ticket_id,
    RemediationStatus.RESOLVED,
    notes="Patch deployed and verified"
)
```

## Continuous Monitoring

### Automated Scanning Schedule

```python
import schedule
import time

def run_all_scans():
    """Run all security scans"""
    
    print(f"\nüîç Starting scheduled security scan - {datetime.now()}")
    
    # Container scanning
    subprocess.run(['./scan_docker_images.sh'])
    
    # Dependency scanning
    scan_python_dependencies()
    
    # Code scanning
    subprocess.run(['./scan_python_code.sh'])
    
    print(f"‚úÖ Scheduled scan complete\n")

# Schedule daily scans
schedule.every().day.at("02:00").do(run_all_scans)

# Schedule weekly pen tests
schedule.every().sunday.at("03:00").do(lambda: subprocess.run(['./pen_test_baseline.sh']))

print("üìÖ Security scan scheduler started")
print("  - Daily scans: 02:00")
print("  - Weekly pen test: Sunday 03:00")

while True:
    schedule.run_pending()
    time.sleep(60)
```

## Reporting and Documentation

### Generate Comprehensive Security Report

```python
import json
from datetime import datetime

def generate_security_report():
    """Generate comprehensive security report"""
    
    # Collect all scan results
    report = {
        'generated_at': datetime.now().isoformat(),
        'period': 'Weekly',
        'summary': {
            'total_vulnerabilities': 0,
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0
        },
        'scans': {
            'containers': load_scan_results('trivy-report.json'),
            'dependencies': load_scan_results('safety-report.json'),
            'code': load_scan_results('bandit-report.json'),
            'penetration_test': load_scan_results('pentest-report.json')
        },
        'remediation': {
            'open_tickets': 0,
            'resolved_this_period': 0,
            'overdue': 0
        },
        'trends': calculate_trends()
    }
    
    # Calculate totals
    for scan_type, results in report['scans'].items():
        if results and 'vulnerabilities' in results:
            for vuln in results['vulnerabilities']:
                severity = vuln.get('severity', 'low').lower()
                report['summary']['total_vulnerabilities'] += 1
                report['summary'][severity] = report['summary'].get(severity, 0) + 1
    
    # Save report
    report_file = f"security-report-{datetime.now().strftime('%Y%m%d')}.json"
    with open(report_file, 'w') as f:
        json.dump(report, f, indent=2)
    
    print(f"‚úÖ Security report generated: {report_file}")
    
    return report

def load_scan_results(filename: str):
    """Load scan results from file"""
    try:
        with open(filename, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        return None

def calculate_trends():
    """Calculate vulnerability trends"""
    # Implementation depends on historical data
    return {
        'vulnerabilities_trend': 'decreasing',
        'mean_time_to_remediate': '5.2 days',
        'sla_compliance_rate': '95%'
    }
```

## Security Checklist

- [ ] Container images scanned before deployment
- [ ] Dependency scanning automated (daily)
- [ ] Code security scanning in CI/CD pipeline
- [ ] Penetration testing scheduled (quarterly minimum)
- [ ] Vulnerability assessment process documented
- [ ] Remediation SLAs defined and tracked
- [ ] Security scan results reviewed regularly
- [ ] Critical vulnerabilities patched within 24-48 hours
- [ ] Security updates applied monthly
- [ ] Incident response plan includes vulnerability disclosure
- [ ] Third-party components inventory maintained
- [ ] Security reports generated and distributed

## Environment Configuration

Add to `.env` file:

```bash
# Vulnerability Scanning
VULN_SCAN_ENABLED=true
VULN_SCAN_SCHEDULE=daily
VULN_SCAN_SEVERITY_THRESHOLD=HIGH

# Container Scanning
CONTAINER_SCAN_TOOL=trivy
CONTAINER_SCAN_ON_BUILD=true

# Dependency Scanning
DEPENDENCY_SCAN_TOOL=safety
DEPENDENCY_SCAN_AUTO_UPDATE=false

# Penetration Testing
PENTEST_SCHEDULE=quarterly
PENTEST_TOOL=owasp-zap
```

## References

- NIST Vulnerability Management: [nvd.nist.gov](https://nvd.nist.gov/)
- OWASP Top 10: [owasp.org/top10](https://owasp.org/www-project-top-ten/)
- CVE Database: [cve.mitre.org](https://cve.mitre.org/)
- CVSS Calculator: [first.org/cvss](https://www.first.org/cvss/)
